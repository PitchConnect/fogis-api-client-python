name: Automated Release Pipeline

on:
  push:
    branches: [main]
    paths-ignore:
      - '**.md'
      - '.github/**'
      - 'docs/**'
      - 'scripts/**'
  pull_request:
    branches: [main]
    types: [closed]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
          - hotfix
      skip_tests:
        description: 'Skip test validation (emergency releases only)'
        required: false
        default: false
        type: boolean

jobs:
  detect-changes:
    name: Detect Changes and Release Type
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true) || github.event_name == 'workflow_dispatch'
    outputs:
      should_release: ${{ steps.analysis.outputs.should_release }}
      release_type: ${{ steps.analysis.outputs.release_type }}
      version: ${{ steps.analysis.outputs.version }}
      has_breaking_changes: ${{ steps.analysis.outputs.has_breaking_changes }}
      commit_count: ${{ steps.analysis.outputs.commit_count }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install packaging requests gitpython

    - name: Analyze changes and determine release type
      id: analysis
      run: |
        # Get the latest tag
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $LATEST_TAG"

        # Get commits since last tag
        if [ "$LATEST_TAG" = "v0.0.0" ]; then
          COMMITS_SINCE_TAG=$(git rev-list --count HEAD)
          COMMIT_RANGE="HEAD"
        else
          COMMITS_SINCE_TAG=$(git rev-list --count ${LATEST_TAG}..HEAD)
          COMMIT_RANGE="${LATEST_TAG}..HEAD"
        fi

        echo "commit_count=$COMMITS_SINCE_TAG" >> $GITHUB_OUTPUT
        echo "Commits since last tag: $COMMITS_SINCE_TAG"

        # If no commits since last tag, skip release
        if [ "$COMMITS_SINCE_TAG" -eq 0 ] && [ "${{ github.event_name }}" != "workflow_dispatch" ]; then
          echo "should_release=false" >> $GITHUB_OUTPUT
          echo "No new commits since last release"
          exit 0
        fi

        # Analyze commit messages for conventional commits
        BREAKING_CHANGES=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -E "BREAKING CHANGE|!:" | wc -l)
        FEATURES=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -E "^feat(\(.+\))?:" | wc -l)
        FIXES=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -E "^fix(\(.+\))?:" | wc -l)

        echo "Breaking changes: $BREAKING_CHANGES"
        echo "Features: $FEATURES"
        echo "Fixes: $FIXES"

        # Determine release type
        if [ "${{ github.event.inputs.release_type }}" != "" ] && [ "${{ github.event.inputs.release_type }}" != "auto" ]; then
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          echo "Manual release type: $RELEASE_TYPE"
        elif [ "$BREAKING_CHANGES" -gt 0 ]; then
          RELEASE_TYPE="major"
          echo "has_breaking_changes=true" >> $GITHUB_OUTPUT
        elif [ "$FEATURES" -gt 0 ]; then
          RELEASE_TYPE="minor"
        elif [ "$FIXES" -gt 0 ] || [ "$COMMITS_SINCE_TAG" -gt 0 ]; then
          RELEASE_TYPE="patch"
        else
          RELEASE_TYPE="patch"
        fi

        echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
        echo "should_release=true" >> $GITHUB_OUTPUT

        # Calculate new version
        CURRENT_VERSION=$(echo $LATEST_TAG | sed 's/^v//')
        if [ "$CURRENT_VERSION" = "0.0.0" ]; then
          NEW_VERSION="1.0.0"
        else
          # Use Python to calculate semantic version
          cat > version_calc.py << 'EOF'
from packaging import version
import os
current = version.parse(os.environ['CURRENT_VERSION'])
release_type = os.environ['RELEASE_TYPE']
if release_type == 'major':
    new_version = version.Version(f'{current.major + 1}.0.0')
elif release_type == 'minor':
    new_version = version.Version(f'{current.major}.{current.minor + 1}.0')
else:
    new_version = version.Version(f'{current.major}.{current.minor}.{current.micro + 1}')
print(str(new_version))
EOF
          NEW_VERSION=$(CURRENT_VERSION=$CURRENT_VERSION RELEASE_TYPE=$RELEASE_TYPE python3 version_calc.py)
          rm version_calc.py
        fi

        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "New version will be: $NEW_VERSION"

  validate-release:
    name: Validate Release Readiness
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.should_release == 'true' && github.event.inputs.skip_tests != 'true'

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Wait for CI workflows
      uses: actions/github-script@v6
      with:
        script: |
          const maxWaitTime = 10 * 60 * 1000; // 10 minutes
          const pollInterval = 30 * 1000; // 30 seconds
          const startTime = Date.now();

          while (Date.now() - startTime < maxWaitTime) {
            const { data: workflows } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head_sha: context.sha,
              status: 'completed',
              per_page: 100
            });

            const requiredWorkflows = ['Test and Publish', 'Docker Build and Test'];
            const workflowResults = {};

            for (const workflow of workflows.workflow_runs) {
              if (requiredWorkflows.includes(workflow.name)) {
                workflowResults[workflow.name] = workflow.conclusion;
              }
            }

            const allCompleted = requiredWorkflows.every(name =>
              workflowResults[name] !== undefined
            );

            const allPassed = requiredWorkflows.every(name =>
              workflowResults[name] === 'success'
            );

            if (allCompleted) {
              if (allPassed) {
                console.log('‚úÖ All required workflows passed');
                return;
              } else {
                console.log('‚ùå Some workflows failed:', workflowResults);
                throw new Error('Required workflows failed');
              }
            }

            console.log('‚è≥ Waiting for workflows to complete...', workflowResults);
            await new Promise(resolve => setTimeout(resolve, pollInterval));
          }

          throw new Error('Timeout waiting for workflows to complete');

  create-release:
    name: Create Automated Release
    runs-on: ubuntu-latest
    needs: [detect-changes, validate-release]
    if: always() && needs.detect-changes.outputs.should_release == 'true' && (needs.validate-release.result == 'success' || needs.validate-release.result == 'skipped')

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Configure Git
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"

    - name: Create and push tag
      run: |
        NEW_VERSION="${{ needs.detect-changes.outputs.version }}"
        git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
        git push origin "v$NEW_VERSION"
        echo "Created and pushed tag: v$NEW_VERSION"

    - name: Generate release notes
      id: release-notes
      run: |
        NEW_VERSION="${{ needs.detect-changes.outputs.version }}"
        LATEST_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")

        if [ -n "$LATEST_TAG" ]; then
          COMMIT_RANGE="${LATEST_TAG}..v$NEW_VERSION"
        else
          COMMIT_RANGE="v$NEW_VERSION"
        fi

        # Generate categorized changelog
        FEATURES=$(git log $COMMIT_RANGE --pretty=format:"- %s (%h)" --grep="^feat" | head -20)
        FIXES=$(git log $COMMIT_RANGE --pretty=format:"- %s (%h)" --grep="^fix" | head -20)
        BREAKING=$(git log $COMMIT_RANGE --pretty=format:"- %s (%h)" --grep="BREAKING CHANGE\|!:" | head -10)
        OTHER=$(git log $COMMIT_RANGE --pretty=format:"- %s (%h)" --invert-grep --grep="^feat\|^fix" | head -10)

        # Create release notes
        cat > release_notes.md << EOF
        ## Release v$NEW_VERSION

        **Release Type**: ${{ needs.detect-changes.outputs.release_type }}
        **Commits**: ${{ needs.detect-changes.outputs.commit_count }}

        ### üöÄ Installation
        \`\`\`bash
        pip install fogis-api-client==$NEW_VERSION
        \`\`\`

        ### üê≥ Container
        \`\`\`bash
        docker pull ghcr.io/pitchconnect/fogis-api-client-python:$NEW_VERSION
        \`\`\`
        EOF

        if [ -n "$BREAKING" ]; then
          echo "" >> release_notes.md
          echo "### ‚ö†Ô∏è BREAKING CHANGES" >> release_notes.md
          echo "$BREAKING" >> release_notes.md
        fi

        if [ -n "$FEATURES" ]; then
          echo "" >> release_notes.md
          echo "### ‚ú® New Features" >> release_notes.md
          echo "$FEATURES" >> release_notes.md
        fi

        if [ -n "$FIXES" ]; then
          echo "" >> release_notes.md
          echo "### üêõ Bug Fixes" >> release_notes.md
          echo "$FIXES" >> release_notes.md
        fi

        if [ -n "$OTHER" ]; then
          echo "" >> release_notes.md
          echo "### üîß Other Changes" >> release_notes.md
          echo "$OTHER" >> release_notes.md
        fi

        echo "" >> release_notes.md
        echo "---" >> release_notes.md
        echo "_This release was automatically created by the automated release pipeline._" >> release_notes.md

    - name: Create GitHub Release
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const releaseNotes = fs.readFileSync('release_notes.md', 'utf8');
          const version = '${{ needs.detect-changes.outputs.version }}';
          const isPrerelease = '${{ needs.detect-changes.outputs.has_breaking_changes }}' === 'true';

          const { data: release } = await github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: `v${version}`,
            name: `Release v${version}`,
            body: releaseNotes,
            draft: false,
            prerelease: isPrerelease
          });

          console.log(`‚úÖ Created release: ${release.html_url}`);

          // Trigger PyPI and GHCR publishing
          await github.rest.actions.createWorkflowDispatch({
            owner: context.repo.owner,
            repo: context.repo.repo,
            workflow_id: 'publish-to-pypi.yml',
            ref: 'main'
          });

          console.log('üöÄ Triggered PyPI and GHCR publishing workflows');

  notify-success:
    name: Notify Release Success
    runs-on: ubuntu-latest
    needs: [detect-changes, create-release]
    if: needs.create-release.result == 'success'

    steps:
    - name: Success notification
      run: |
        echo "üéâ Successfully created release v${{ needs.detect-changes.outputs.version }}"
        echo "üì¶ PyPI: https://pypi.org/project/fogis-api-client/${{ needs.detect-changes.outputs.version }}/"
        echo "üê≥ GHCR: ghcr.io/pitchconnect/fogis-api-client-python:${{ needs.detect-changes.outputs.version }}"
        echo "üîó Release: https://github.com/${{ github.repository }}/releases/tag/v${{ needs.detect-changes.outputs.version }}"
