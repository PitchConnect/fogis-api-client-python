name: Automated Release Pipeline

on:
  push:
    branches: [main]
    paths-ignore:
      - '**.md'
      - '.github/**'
      - 'docs/**'
      - 'scripts/**'
  pull_request:
    branches: [main]
    types: [closed]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
          - hotfix
      skip_tests:
        description: 'Skip test validation (emergency releases only)'
        required: false
        default: false
        type: boolean

jobs:
  detect-changes:
    name: Detect Changes and Release Type
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true) || github.event_name == 'workflow_dispatch'
    outputs:
      should_release: ${{ steps.analysis.outputs.should_release }}
      release_type: ${{ steps.analysis.outputs.release_type }}
      version: ${{ steps.analysis.outputs.version }}
      has_breaking_changes: ${{ steps.analysis.outputs.has_breaking_changes }}
      commit_count: ${{ steps.analysis.outputs.commit_count }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install packaging requests gitpython

    - name: Analyze changes and determine release type
      id: analysis
      run: |
        # Get the latest tag
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $LATEST_TAG"

        # Get commits since last tag
        if [ "$LATEST_TAG" = "v0.0.0" ]; then
          COMMITS_SINCE_TAG=$(git rev-list --count HEAD)
          COMMIT_RANGE="HEAD"
        else
          COMMITS_SINCE_TAG=$(git rev-list --count ${LATEST_TAG}..HEAD)
          COMMIT_RANGE="${LATEST_TAG}..HEAD"
        fi

        echo "commit_count=$COMMITS_SINCE_TAG" >> $GITHUB_OUTPUT
        echo "Commits since last tag: $COMMITS_SINCE_TAG"

        # If no commits since last tag, skip release
        if [ "$COMMITS_SINCE_TAG" -eq 0 ] && [ "${{ github.event_name }}" != "workflow_dispatch" ]; then
          echo "should_release=false" >> $GITHUB_OUTPUT
          echo "No new commits since last release"
          exit 0
        fi

        # Analyze commit messages for conventional commits
        BREAKING_CHANGES=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -E "BREAKING CHANGE|!:" | wc -l)
        FEATURES=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -E "^feat(\(.+\))?:" | wc -l)
        FIXES=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -E "^fix(\(.+\))?:" | wc -l)

        echo "Breaking changes: $BREAKING_CHANGES"
        echo "Features: $FEATURES"
        echo "Fixes: $FIXES"

        # Determine release type
        if [ "${{ github.event.inputs.release_type }}" != "" ] && [ "${{ github.event.inputs.release_type }}" != "auto" ]; then
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          echo "Manual release type: $RELEASE_TYPE"
        elif [ "$BREAKING_CHANGES" -gt 0 ]; then
          RELEASE_TYPE="major"
          echo "has_breaking_changes=true" >> $GITHUB_OUTPUT
        elif [ "$FEATURES" -gt 0 ]; then
          RELEASE_TYPE="minor"
        elif [ "$FIXES" -gt 0 ] || [ "$COMMITS_SINCE_TAG" -gt 0 ]; then
          RELEASE_TYPE="patch"
        else
          RELEASE_TYPE="patch"
        fi

        echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
        echo "should_release=true" >> $GITHUB_OUTPUT

        # Calculate new version using simple bash logic
        CURRENT_VERSION=$(echo $LATEST_TAG | sed 's/^v//')
        if [ "$CURRENT_VERSION" = "0.0.0" ]; then
          NEW_VERSION="1.0.0"
        else
          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          # Calculate new version based on release type
          if [ "$RELEASE_TYPE" = "major" ]; then
            NEW_VERSION="$((MAJOR + 1)).0.0"
          elif [ "$RELEASE_TYPE" = "minor" ]; then
            NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
          else
            NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
          fi
        fi

        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "New version will be: $NEW_VERSION"

  validate-release:
    name: Validate Release Readiness
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.should_release == 'true' && github.event.inputs.skip_tests != 'true'

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Wait for CI workflows
      uses: actions/github-script@v6
      with:
        script: |
          const maxWaitTime = 10 * 60 * 1000; // 10 minutes
          const pollInterval = 30 * 1000; // 30 seconds
          const startTime = Date.now();

          while (Date.now() - startTime < maxWaitTime) {
            const { data: workflows } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head_sha: context.sha,
              status: 'completed',
              per_page: 100
            });

            const requiredWorkflows = ['Test and Publish', 'Docker Build and Test'];
            const workflowResults = {};

            for (const workflow of workflows.workflow_runs) {
              if (requiredWorkflows.includes(workflow.name)) {
                workflowResults[workflow.name] = workflow.conclusion;
              }
            }

            const allCompleted = requiredWorkflows.every(name =>
              workflowResults[name] !== undefined
            );

            const allPassed = requiredWorkflows.every(name =>
              workflowResults[name] === 'success'
            );

            if (allCompleted) {
              if (allPassed) {
                console.log('‚úÖ All required workflows passed');
                return;
              } else {
                console.log('‚ùå Some workflows failed:', workflowResults);
                throw new Error('Required workflows failed');
              }
            }

            console.log('‚è≥ Waiting for workflows to complete...', workflowResults);
            await new Promise(resolve => setTimeout(resolve, pollInterval));
          }

          throw new Error('Timeout waiting for workflows to complete');

  create-release:
    name: Create Automated Release
    runs-on: ubuntu-latest
    needs: [detect-changes, validate-release]
    if: always() && needs.detect-changes.outputs.should_release == 'true' && (needs.validate-release.result == 'success' || needs.validate-release.result == 'skipped')

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Configure Git
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"

    - name: Update setup.py version
      run: |
        NEW_VERSION="${{ needs.detect-changes.outputs.version }}"
        echo "üìù Updating setup.py to version $NEW_VERSION"

        # Update version in setup.py
        sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"$NEW_VERSION\"/" setup.py

        # Verify the update
        UPDATED_VERSION=$(python3 -c "import re; content=open('setup.py').read(); match=re.search(r'\"version\":\s*\"([^\"]+)\"', content); print(match.group(1) if match else 'unknown')")
        echo "Updated version in setup.py: $UPDATED_VERSION"

        if [ "$UPDATED_VERSION" != "$NEW_VERSION" ]; then
          echo "‚ùå Failed to update version in setup.py"
          exit 1
        fi

        echo "‚úÖ Successfully updated setup.py to version $NEW_VERSION"

    - name: Commit version update
      run: |
        NEW_VERSION="${{ needs.detect-changes.outputs.version }}"

        # Check if there are changes to commit
        if git diff --quiet setup.py; then
          echo "‚ÑπÔ∏è No changes to setup.py (version already up to date)"
        else
          git add setup.py
          git commit -m "chore: bump version to $NEW_VERSION [skip ci]"
          git push origin main
          echo "‚úÖ Committed and pushed version update to main"
        fi

    - name: Create and push tag
      run: |
        NEW_VERSION="${{ needs.detect-changes.outputs.version }}"
        git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
        git push origin "v$NEW_VERSION"
        echo "Created and pushed tag: v$NEW_VERSION"

    - name: Generate release notes
      id: release-notes
      run: |
        NEW_VERSION="${{ needs.detect-changes.outputs.version }}"
        LATEST_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")

        if [ -n "$LATEST_TAG" ]; then
          COMMIT_RANGE="${LATEST_TAG}..v$NEW_VERSION"
        else
          COMMIT_RANGE="v$NEW_VERSION"
        fi

        # Generate categorized changelog with enhanced details
        FEATURES=$(git log $COMMIT_RANGE --pretty=format:"- %s (%h)" --grep="^feat" | head -20)
        FIXES=$(git log $COMMIT_RANGE --pretty=format:"- %s (%h)" --grep="^fix" | head -20)
        BREAKING=$(git log $COMMIT_RANGE --pretty=format:"- %s (%h)" --grep="BREAKING CHANGE\|!:" | head -10)
        OTHER=$(git log $COMMIT_RANGE --pretty=format:"- %s (%h)" --invert-grep --grep="^feat\|^fix" | head -10)

        # Extract PR numbers and issue references from commits
        PR_NUMBERS=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -oP '#\d+' | sort -u | tr '\n' ' ')
        ISSUE_REFS=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -oP '(?:Fix|Fixes|Close|Closes|Resolve|Resolves) #\d+' | sort -u)

        # Create comprehensive release notes
        cat > release_notes.md << EOF
        ## Release v$NEW_VERSION

        **Release Type**: ${{ needs.detect-changes.outputs.release_type }}
        **Commits**: ${{ needs.detect-changes.outputs.commit_count }}
        **Date**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

        ### üì¶ Installation

        #### PyPI Package
        \`\`\`bash
        pip install fogis-api-client==$NEW_VERSION
        \`\`\`

        #### Container Image
        \`\`\`bash
        docker pull ghcr.io/pitchconnect/fogis-api-client-python:$NEW_VERSION
        \`\`\`

        ### üìù What's Changed
        EOF

        if [ -n "$BREAKING" ]; then
          echo "" >> release_notes.md
          echo "### ‚ö†Ô∏è BREAKING CHANGES" >> release_notes.md
          echo "" >> release_notes.md
          echo "$BREAKING" >> release_notes.md
          echo "" >> release_notes.md
          echo "> **Note**: This release contains breaking changes. Please review the changes carefully before upgrading." >> release_notes.md
        fi

        if [ -n "$FEATURES" ]; then
          echo "" >> release_notes.md
          echo "### ‚ú® New Features" >> release_notes.md
          echo "" >> release_notes.md
          echo "$FEATURES" >> release_notes.md
        fi

        if [ -n "$FIXES" ]; then
          echo "" >> release_notes.md
          echo "### üêõ Bug Fixes" >> release_notes.md
          echo "" >> release_notes.md
          echo "$FIXES" >> release_notes.md
        fi

        if [ -n "$OTHER" ]; then
          echo "" >> release_notes.md
          echo "### üîß Other Changes" >> release_notes.md
          echo "" >> release_notes.md
          echo "$OTHER" >> release_notes.md
        fi

        # Add related PRs and issues section
        if [ -n "$PR_NUMBERS" ]; then
          echo "" >> release_notes.md
          echo "### üîó Related Pull Requests" >> release_notes.md
          echo "" >> release_notes.md
          for pr in $PR_NUMBERS; do
            echo "- PR $pr: https://github.com/${{ github.repository }}/pull/${pr#\#}" >> release_notes.md
          done
        fi

        if [ -n "$ISSUE_REFS" ]; then
          echo "" >> release_notes.md
          echo "### üêõ Issues Resolved" >> release_notes.md
          echo "" >> release_notes.md
          echo "$ISSUE_REFS" | while read -r issue_ref; do
            issue_num=$(echo "$issue_ref" | grep -oP '#\d+')
            echo "- $issue_ref: https://github.com/${{ github.repository }}/issues/${issue_num#\#}" >> release_notes.md
          done
        fi

        # Add changelog link
        echo "" >> release_notes.md
        echo "### üìö Full Changelog" >> release_notes.md
        echo "" >> release_notes.md
        if [ -n "$LATEST_TAG" ]; then
          echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${LATEST_TAG}...v$NEW_VERSION" >> release_notes.md
        else
          echo "**Full Changelog**: https://github.com/${{ github.repository }}/commits/v$NEW_VERSION" >> release_notes.md
        fi

        echo "" >> release_notes.md
        echo "---" >> release_notes.md
        echo "" >> release_notes.md
        echo "_This release was automatically created by the automated release pipeline._" >> release_notes.md
        echo "_For detailed information about each change, please refer to the linked PRs and issues above._" >> release_notes.md

    - name: Create GitHub Release
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const releaseNotes = fs.readFileSync('release_notes.md', 'utf8');
          const version = '${{ needs.detect-changes.outputs.version }}';
          const isPrerelease = '${{ needs.detect-changes.outputs.has_breaking_changes }}' === 'true';

          const { data: release } = await github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: `v${version}`,
            name: `Release v${version}`,
            body: releaseNotes,
            draft: false,
            prerelease: isPrerelease
          });

          console.log(`‚úÖ Created release: ${release.html_url}`);

          // Trigger PyPI and GHCR publishing
          await github.rest.actions.createWorkflowDispatch({
            owner: context.repo.owner,
            repo: context.repo.repo,
            workflow_id: 'publish-to-pypi.yml',
            ref: 'main'
          });

          console.log('üöÄ Triggered PyPI and GHCR publishing workflows');

  notify-success:
    name: Notify Release Success
    runs-on: ubuntu-latest
    needs: [detect-changes, create-release]
    if: needs.create-release.result == 'success'

    steps:
    - name: Success notification
      run: |
        echo "üéâ Successfully created release v${{ needs.detect-changes.outputs.version }}"
        echo "üì¶ PyPI: https://pypi.org/project/fogis-api-client/${{ needs.detect-changes.outputs.version }}/"
        echo "üê≥ GHCR: ghcr.io/pitchconnect/fogis-api-client-python:${{ needs.detect-changes.outputs.version }}"
        echo "üîó Release: https://github.com/${{ github.repository }}/releases/tag/v${{ needs.detect-changes.outputs.version }}"
